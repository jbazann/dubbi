---
import MainLayout from "@l/MainLayout.astro";
import es from "@lib/lang/es"
import cookies from "@lib/cookies.json"
import Intro from "@c/pages/Intro.astro";

let theme
if (Astro.cookies.has(cookies.theme)) theme = Astro.cookies.get(cookies.theme)?.value
let {hideIntro} = Object.fromEntries(Astro.request.method === 'POST' ? await Astro.request.formData() : [])
---

<MainLayout langlib={es} theme={theme}>
    {hideIntro !== 'true' && <Intro lang="es"/> }
    <section>
        <h3>Lecciones aprendidas</h3>
        <p>
            La primer y más importante lección que aprendí es que <em>no debería</em>
            ignorar lo que personas más inteligentes y experimentadas que yo están
            haciendo. React fue hecho para ser renderizado en el cliente. Hay
            conocimiento implícito en esa idea.
        </p>
        <p>
            Sabía desde el principio que los pasos que estaba siguiendo para
            renderizar React estáticamente no iban a escalar más allá de un 
            proyecto personal. Lo que debería haber sabido, además, es
            cuánto iba a impactar esto en mi productividad.
        </p>
        <p>
            Tuve que resolver un montón de problemas artificiales e innecesarios, que solo
            aparecen cuando estás trabajando en contra de tu framework. Esto se volvió
            especialmente evidente cuando empecé a trabajar con Astro, y de repente
            todo lo que quería hacer era soportado y fácil.
        </p>
        <p>
            La segunda lección que aprendí es que <em>debería</em> ignorar 
            lo que personas más inteligentes y experimentadas que yo están haciendo.
            Si entiendo sus rasones, hay ocasiones en las que los requerimientos
            permiten mejores estratégias, incluso si menos ortodoxas.
        </p>
        <p>
            Todavía pienso que incluír contenido oculto en vez de generarlo
            dinámicamente es una decisión ingenieril válida. El beneficio
            puede ser considerado una micro-optimización en aislamiento,
            pero en el frontend, estas suman a la experiencia final.
        </p>
        <p>
            <em>Algunos</em> tiempos de carga son esperados al usar aplicaciones web,
            especialmente cuando entendés cómo se construyen.
            Pero si podés usar CSS para insertar respuestas instantáneas entre
            tiempos de carga, las pausas se vuelven necesarias.
        </p>
        <p>
            Puedo moverme por los menús tan rápido como mi mouse puede clickear,
            pero en algún punto tengo que parar para pensar en lo que estoy haciendo.
            En ese momento es cuando espero que mi computadora procese el próximo paso.
        </p>
        <p>
            Pre-procesar el próximo paso consume mucha RAM?
            Es mucha carga de red? Hay demasiados flujos alternativos?
            Todavía no estoy convencido de que estos no son problemas
            macroscópicos que puedan ser resueltos con un diseño más inteligente.
        </p>
        <p>
            Las computadoras son más rápidas que nosotros, es desafortunado que
            a los fines de ser más productivos, dividimos sistemas en tantas partes
            que se empieza a perder de vista la experiencia global.
        </p>
    </section>
</MainLayout>